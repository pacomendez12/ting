#summary ting library usage tutorial
#labels Featured

=Creating a Thread=
first of all we need to include *ting* header to use the library
{{{
#include <ting/ting.hpp>
}}}

After that we can start using the library. To create a thread one needs to derive a new class representing her thread from ting::Thread base class and override its ting::Thread::Run() method
{{{
class MyThread : public ting::Thread{
    //define some variables specific to your thread,
    //in this example we have two ints: a and b
    int a;
    int b;

public:
    //override
    void Run(){
        //do some thread actions
    };
};
}}}
After we have our thread class defined we can create an object of this class and start the thread execution by calling ting::Thread::Start() method on it
{{{
MyThread thr; //create an object on the stack for simplicity
thr.Start();//start thread execution
}}}
After starting the thread we can wait for it to finish its execution by calling ting::Thread::Join() method on the thread object. After this call we can surely say that thread has finished its execution
{{{
thr.Join();
}}}
Note that the destructor of _ting::Thread_ class also calls the _Join()_ method to ensure that the thread is finished before destroying the thread object. Before calling _Join()_ the destructor pushes a _ting::QuitMessage _ to thread's message queue (see next section about Messages and Queues), so you probably should do message handling in your implementation of _ting::Thread::Run()_ method.



=Messages and Message Queues=
Every thread object has its own message queue (_ting::Thread::queue_), thus the thread can receive and handle messages from other threads.

Typical implementation of the _ting::Thread::Run()_ method which handles messages looks as follows
{{{
void MyThread::Run(){
    while(!this->quitFlag){
        ting::Ptr<ting::Message> m = this->queue.GetMsg();
        m->Handle();
    }
};
}}}
This example use _ting::Queue::GetMsg()_ to retrieve messages from the queue, _GetMsg()_ blocks execution if there are no messages on the queue until some message arrives.

It is also possible to use _ting::Queue::PeekMsg()_ which does not block execution, typical implementation of _Run()_ method will look as follows

{{{
void MyThread::Run(){
    while(!this->quitFlag){
        //handle all messages on the queue
        while(ting::Ptr<ting::Message> m = this->queue.PeekMsg()){
            m->Handle();
        }
        //do some actions to be done every cycle
        //...
    }
};
}}}

Note that each thread object has a _quitFlag_ volatile member variable which serves as a convenient indicator to the thread showing when the thread should finish its execution.

Note that _ting::QuitMessage _ will set the _quitFlag_ when it is handled.

==Creating your own message==
Messages is a mean to ask some thread to execute some code.
To do this one needs to create his/her own message (implementing its handler) and send it to the threads queue.

Let's define our own message class deriving it from _ting::Message _
{{{
class MyMessage : public ting::Message{
    MyThread *myThr;
public:
    MyMessage(MyThread *mt) :
            myThr(mt)
    {
        //assert that this->myThr is not 0.
        //...
    };

    //override
    void Handle(){
        //implement handler for this message
        this->myThr->a = 10;
        this->myThr->b = 20;
    };
};
}}}

Now, we can send this message to the thread's queue
{{{
//Create and start the thread we're going to send the message to
MyThread thread;
thread.Start();

//create the message
std::auto_ptr<ting::Message> msg( new MyMessage(&thread) );

//send the message
thread.PushMessage(msg);
}}}
Note that our _Handle()_ method accesses private variables of the thread, so one should probably add a friend declaration to the MyThread class to indicate that MyMessage is a friend of MyThread class and can access its private variables. This will also ideologically indicate that MyThread can handle messages of type MyMessage.