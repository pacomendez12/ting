#summary ting debugging facilities
#labels Featured



= Debugging with ting =

*ting* provides some useful debugging instruments like assertions, tracing and logging.
All the debugging functions are wrapped into macros in order to be able to turn them off in the release builds and turn them on in the debug builds.

For debug builds one needs to define the DEBUG macro. When DEBUG macro is defined ting will do additional checks and assertions which slightly decrease the performance, but for that you will be warned if something goes wrong meaning that there is some bug in the program.
All the ting debug facilities you use in your program will be turned on as well.

For release builds just do not define the DEBUG macro and all debug macros will be turned off.

Note: for g++ compiler macro can be defined by supplying the -DDEBUG key to the g++.

Note: some debug macros are always turned on, regardless of DEBUG macro defined or not. All such macros have `_`ALWAYS suffix in their names.



<br>
= Header file =

In order to use ting debugging facilities, include the following header file:
{{{
#include <ting/debug.hpp>
}}}



<br>
= Semicolons after macros =

Note, that semicolons after ting debugging macros are not required. Semicolons are already included inside of the macros. This is because macros can be turned off in release builds, in which case there will be redundant semicolons in your program since macros are evaluated to nothing.

For example
{{{
int a = 35;

ASSERT(a == 35)  // correct
TRACE(<< "Hello world!" << std::endl) // correct

ASSERT(a == 35); // incorrect
TRACE(<< "Hello world!" << std::endl); // incorrect
}}}



<br>
= ASSERTIONS =

Following assertion macros are available:


<br>
*ASSERT(x)*<br>
*ASSERT_ALWAYS(x)*<br>
where *x* is a boolean expression.

Example:
{{{
int a = 13;
ASSERT(a == 13)
ASSERT(sizeof(int) == 4)
ASSERT(sizeof(a) == 4 && sizeof(a) == sizeof(int))
}}}


<br>
*ASSERT_INFO(x, y)*<br>
*ASSERT_INFO_ALWAYS(x, y)*<br>
where *x* is a boolean expression.<br>
*y* is a logging which needs to be done in case of assertion failure.

Example:
{{{
int a = 13;
ASSERT_INFO(a == 14, "a is not 14, a is " << a)
}}}
Note, that std::endl is not required as well as leading operator <<.


<br>
*ASSERT_EXEC(x)*<br>
where *x* is a boolean expression.

This assertion type guarantees that the expression will be executed. In debug build the expression value will be checked for true, in release build it will not be checked.

Example:
{{{
ASSERT_EXEC(DoSomethingAndReturnTrueOnSuccess())
}}}


<br>
*ASS(x)*<br>
where *x* is a *pointer* or _ting::Ref_, or _ting::Ptr_. Generally speaking, *x* is any value which can be automatically converted to bool-like type and which has operator->() defined.

This assertion is used to check pointer value for 0 before dereferencing it with *operator->()*.

Example:
{{{
class TestClass{
public:
    int a;
};

TestClass *c = new TestClass();

//make sure, "c" is not 0 before accessing member a.
ASS(c)->a = 13;
int b = ASS(c)->a;
}}}


<br>
*STATIC_ASSERT(x)*<br>
where *x* is a boolean expression which can be evaluated at compile time.

Static assertion is used to check some conditions in compile time. For example, check size of some class to have a certain value.
STATIC_ASSERT() macro can be used in global scope, inside of a function, inside of a class declaration. It is ok to put STATIC_ASSERT() to template declaration but it will not be checked in that case, i.e. it will not have any effect when using inside of a template.

Example:
{{{
STATIC_ASSERT(sizeof(int) == 4)


class TestClass{
public:
    int a;

    //make sure that unsigned char type and signed char type are 8 bit wide.
    STATIC_ASSERT((unsigned char)(-1) == 0xFF)
    STATIC_ASSERT((signed char)(0xFF) == -1)
    STATIC_ASSERT(sizeof(unsigned char) == sizeof(signed char))
};


void MyFunction(TestClass& arg){
    STATIC_ASSERT(sizeof(TestClass) == sizeof(int))
    //...
}
}}}




<br>
= TRACEs and LOGs =

Macros for tracing and logging are available. Traceing macros output info into standard output. Logging macros output info into _output.log_ file.

Following macros are available:

<br>
*LOG(x)*<br>
*TRACE(x)*<br>
*TRACE_AND_LOG(x)*<br>
*LOG_ALWAYS(x)*<br>
*TRACE_ALWAYS(x)*<br>
*TRACE_AND_LOG_ALWAYS(x)*<br>
where *x* is a std::cout like output.

Example:
{{{
LOG(<< "Hello World!" << std::endl)

TRACE(<< "sizeof(int) = " << sizeof(int))
TRACE(<< " and sizeof(short) = " << sizeof(short) << std::endl)

TRACE_AND_LOG(
        << "Here is some more info about type sizes:" << std::endl
        << "sizeof(void*) = " << sizeof(void) << std::endl
        << "sizeof(char) = " << sizeof(char) << std::endl
        << "sizeof(float) = " << sizeof(float) << std::endl
        << "sizeof(double) = " << sizeof(double) << std::endl
    )
}}}



<br>
= Debug code =

There is a *DEBUG_CODE(x)* macro which allows you to define some piece of code which will be present only in debug build and will be excluded from release build (the one created without DEBUG macro defined).

Example:
{{{
DEBUG_CODE(int a = ) DoSomethingAndReturnMinusOneOnFailure();

ASSERT(a != -1)
}}}

The macro is useful for defining one-line code pieces. Whenever multiple lines of debugging code needs to be defined, one should use
{{{
#ifdef DEBUG

//Do some checks required only in debug builds
//...

#endif//~DEBUG
}}}