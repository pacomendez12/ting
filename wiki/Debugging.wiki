#summary ting debugging facilities



= Debugging with ting =

*ting* provides some useful debugging instruments like assertions, tracing and logging.
All the debugging functions are wrapped into macros in order to be able to turn them off in the release builds and turn them on in the debug builds.

For debug builds one needs to define the DEBUG macro. When DEBUG macro is defined ting will do additional checks and assertions which slightly decrease the performance, but for that you will be warned if something goes wrong meaning that there is some bug in the program.
All the ting debug facilities you use in your program will be turned on as well.

For release builds just do not define the DEBUG macro and all debug macros will be turned off.

Note: for g++ compiler macro can be defined by supplying the -DDEBUG key to the g++.

Note: some debug macros are always turned on, regardless of DEBUG macro defined or not. All such macros have `_`ALWAYS suffix in their names.



<br>
= Header file =

In order to use ting debugging facilities, include the following header file:
{{{
#include <ting/debug.hpp>
}}}



<br>
= Semicolons after macros =

Note, that semicolons after ting debugging macros are not required. Semicolons are already included inside of the macros. This is because macros can be turned off in release builds, in which case there will be redundant semicolons in your program since macros are evaluated to nothing.

For example
{{{
int a = 35;

ASSERT(a == 35)  // correct
TRACE(<< "Hello world!" << std::endl) // correct

ASSERT(a == 35); // incorrect
TRACE(<< "Hello world!" << std::endl); // incorrect
}}}



<br>
= ASSERTIONS =

Following assertion macros are available:


<br>
*ASSERT(x)*<br>
*ASSERT_ALWAYS(x)*<br>
where *x* is a boolean expression.

Example:
{{{
int a = 13;
ASSERT(a == 13)
ASSERT(sizeof(int) == 4)
ASSERT(sizeof(a) == 4 && sizeof(a) == sizeof(int))
}}}


<br>
*ASSERT_INFO(x, y)*<br>
*ASSERT_INFO_ALWAYS(x, y)*<br>
where *x* is a boolean expression.<br>
*y* is a logging which needs to be done in case of assertion failure.

Example:
{{{
int a = 13;
ASSERT_INFO(a == 14, "a is not 14, a is " << a)
}}}
Note, that std::endl is not required as well as leading operator <<.


<br>
*ASSERT_EXEC(x)*<br>
where *x* is a boolean expression.

This assertion type guarantees that the expression will be executed. In debug build the expression value will be checked for true, in release build it will not be checked.

Example:
{{{
ASSERT_EXEC(DoSomethingAndReturnTrueOnSuccess())
}}}


<br>
*ASS(x)*<br>
where *x* is a *pointer* or _ting::Ref_, or _ting::Ptr_. Generally speaking, *x* is any value which can be automatically converted to bool-like type and which has operator->() defined.

This assertion is used to check pointer value for 0 before dereferencing it with *operator->()*.

Example:
{{{
class TestClass{
public:
    int a;
};

TestClass *c = new TestClass();

//make sure, "c" is not 0 before accessing member a.
ASS(c)->a = 13;
int b = ASS(c)->a;
}}}

NOTE: that due to implementation specifics, the ASS() macro evaluates the argument two times. So, one should be careful when using the macro for checking, for example, the value returned by function, like this:
{{{
bool retVal = ASS(UpdateAndReturnResult());
}}}
Thus, in this case, the UpdateAndReturnResult() function will be called twice when debug mode is enabled (i.e. DEBUG macro is defined).


<br>
*STATIC_ASSERT(x)*<br>
where *x* is a boolean expression which can be evaluated at compile time.

Static assertion is used to check some conditions in compile time. For example, check size of some class to have a certain value.
STATIC_ASSERT() macro can be used in global scope, inside of a function, inside of a class declaration. It is ok to put STATIC_ASSERT() to template declaration but it will not be checked in that case, i.e. it will not have any effect when using inside of a template.

Example:
{{{
STATIC_ASSERT(sizeof(int) == 4)


class TestClass{
public:
    int a;

    //make sure that unsigned char type and signed char type are 8 bit wide.
    STATIC_ASSERT((unsigned char)(-1) == 0xFF)
    STATIC_ASSERT((signed char)(0xFF) == -1)
    STATIC_ASSERT(sizeof(unsigned char) == sizeof(signed char))
};


void MyFunction(TestClass& arg){
    STATIC_ASSERT(sizeof(TestClass) == sizeof(int))
    //...
}
}}}




<br>
= TRACEs and LOGs =

Macros for tracing and logging are available. Tracing macros output info into standard output. Logging macros output info into _output.log_ file.

Following macros are available:

<br>
*LOG(x)*<br>
*TRACE(x)*<br>
*TRACE_AND_LOG(x)*<br>
*LOG_ALWAYS(x)*<br>
*TRACE_ALWAYS(x)*<br>
*TRACE_AND_LOG_ALWAYS(x)*<br>
where *x* is a std::cout like output.

Example:
{{{
LOG(<< "Hello World!" << std::endl)

TRACE(<< "sizeof(int) = " << sizeof(int))
TRACE(<< " and sizeof(short) = " << sizeof(short) << std::endl)

TRACE_AND_LOG(
        << "Here is some more info about type sizes:" << std::endl
        << "sizeof(void*) = " << sizeof(void) << std::endl
        << "sizeof(char) = " << sizeof(char) << std::endl
        << "sizeof(float) = " << sizeof(float) << std::endl
        << "sizeof(double) = " << sizeof(double) << std::endl
    )
}}}



<br>
= Debug code =

There is a *DEBUG_CODE(x)* macro which allows you to define some piece of code which will be present only in debug build and will be excluded from release build (the one created without DEBUG macro defined).

Example:
{{{
DEBUG_CODE(int a = ) DoSomethingAndReturnMinusOneOnFailure();

ASSERT(a != -1)
}}}

The macro is useful for defining one-line code pieces. Whenever multiple lines of debugging code needs to be defined, one should use
{{{
#ifdef DEBUG

//Do some checks required only in debug builds
//...

#endif//~DEBUG
}}}



<br>
= Checking the code is executed in correct thread =

In multi-threaded applications, sometimes, there are some constraints regarding in which thread the particular code should be executed. For example, you create some object in one thread and this object requires that its methods would be called from exactly the same thread where it was created. To avoid errors, it is good to put assertions in the methods of that object to check that the method is called from correct thread.

To achieve that, one can use the _ting::Thread::GetCurrentThreadID()_ static function.

Example:
{{{
//save thread ID
unsigned long threadID = ting::Thread::GetCurrentThreadID();

//...

//make sure we are in correct thread
ASSERT(threadID == ting::Thread::GetCurrentThreadID())
}}}