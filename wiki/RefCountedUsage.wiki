#summary Using the ting reference counting pointers.


= Introduction =

*ting* provides facilities for creating reference counted objects and use reference counting pointers to these objects. This allows free the object memory automatically whenever no active references to that object left.

Strong references and weak references are supported.

Reference counted object may be referenced from different threads. _ting::RefCounted_ referencing mechanism is thread safe in the sense that if two threads hold strong reference to the object and in both of them the strong reference cease to exist, then the object will not be deleted twice, but only once, as required to avoid application crash.

Whenever there is a strong reference to the object, on can be assured that the object will exist and will not be deleted. The object is deleted when there are no strong references left.


<br>
= Header file =

In order to use the ting::Ref one needs to include the file:
{{{
#include <ting/Ref.hpp>
}}}



<br>
= Creating reference counted class =

To create a class for your reference counted object just derive from ting::RefCounted, as follows:
{{{
class MyClass : public ting::RefCounted{
    MyClass(int valueA, int valueB) :
            a(valueA),
            b(valueB)
    {}
public:
    int a;
    int b;

    static ting::Ref<MyClass> New(int valueA, int valueB){
        return ting::Ref<MyClass>(
                new MyClass(valueA, valueB)
            );
    }
};
}}}
Note, that constructor of the class is intentionally made private and a static New() method introduced to construct the object. This is not a mandatory technique but it is a good practice, and using this with ting::RefCounted objects is encouraged. As of current version (ting-0.4) the constructor of ting::RefCounted class is public, but it is possible that in later versions of ting it will be made protected, so it will only be possible to construct the object from within its own method, e.g. New(). Also, using this practice will help you assure that the object of your class will only be accessed through ting::Ref references, and not via traditional C pointers, whose usage with ting::RefCounted, if not forbidden, then, at least, strongly _not_ recommended.



<br>
= Referencing objects with ting::Ref =

_ting::Ref_ is a template class representing a strong reference to reference counted object (derived from ting::RefCounted). Note, that it is not allowed to create references using *new* operator (the *new* operator is private anyway).

The usage is quite simple:

{{{
//create first object
ting::Ref<MyClass> globalMC = MyClass::New(0, 1);;

{
    //create second object
    ting::Ref<MyClass> mc = MyClass::New(13, 14);

    mc->a = 15;
    int k = mc->b;

    globalMC = mc;
    //At this point, the first object will be deleted.
    //And "globalRC" reference is pointing to second object as "mc" does.
}
//At this point the "mc" reference is destroyed as it went out of scope.
//But "globalMC" still references to the second object.

glomalMC.Reset();//Reset this reference, it will no longer point to any object.
//At this point, the second object will be deleted, as the last strong reference
//to it was destroyed, or reset.
}}}



<br>
= Referencing objects with ting::WeakRef =

_ting::WeakRef_ is a template class representing a weak reference. Weak reference does not guarantee that the object is still alive. Actually, if there are several strong references to the object and there are several weak references to the same object, then, after all strong references go out of scope the object will be destroyed immediately, despite the fact that some weak references still exist.

Note, that it is not allowed to access the object through weak reference directly. In order to access the object, one needs to construct a strong reference from the weak reference and then check that the constructed strong reference is valid. If the constructed strong reference is not valid, then the object was deleted before because all strong references to it have ceased to exist.

The usage is as follows:
{{{
//create object
ting::Ref<MyClass> mc = MyClass::New(13, 14);

//create weak reference to the object
ting::WeakRef<MyClass> wmc = mc;

//access some object member using the weak reference
if(ting::Ref<MyClass> hmc = wmc){
    hmc->a = 35;
    int k = hmc->b;
    //...
}

//destroy last strong reference to the object
mc.Reset();//the object will be deleted

//try accessing some object member using the weak reference
if(ting::Ref<MyClass> hmc = wmc){
   //Will never get there as the object is destroyed and
   //weak reference in not valid anymore
}
}}}



<br>
= Memory leaks =

The purpose of the reference counting mechanism is to avoid memory leaks, but, nevertheless, memory leaks are still possible. The scenario of memory leaking when using reference counting is called a cycling references.

If there are two objects which hold strong references to each other then these two objects will never be destroyed, even if all strong references to them from "outside" world have went out of scope. Because there are still at least 1 strong reference to each of the object exists (reference being held by another object).

To avoid such situations, one needs to do a proper design of his/her classes and use weak reference in one of such objects and strong reference in another one. This is the _main_ reason why weak references are introduced.