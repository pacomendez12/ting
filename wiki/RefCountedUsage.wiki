#summary Using the ting reference counting pointers.
#labels Featured


= Introduction =

*ting* provides facilities for creating reference counted objects and use reference counting pointers to these objects. This allows free the object memory automatically whenever no active references to that object left.

Hard references and weak references are supported.

Reference counted object may be referenced from different threads. _ting::RefCounted_ referencing mechanism is thread safe in the sense that if two threads hold hard reference to the object and in both of them the hard reference cease to exist, then the object will not be deleted twice, but only once, as required to avoid application crash.

Whenever there is a hard reference to the object, on can be assured that the object will exist and will not be deleted. The object is deleted when there are no hard references left.


<br>
= Header file =

In order to use the ting::Ref one needs to include the file:
{{{
#include <ting/Ref.hpp>
}}}



<br>
= Creating reference counted class =

To create a class for your reference counted object just derive from ting::RefCounted, as follows:
{{{
class MyClass : public ting::RefCounted{
    MyClass(int valueA, int valueB) :
            a(valueA),
            b(valueB)
    {}
public:
    int a;
    int b;

    static ting::Ref<MyClass> New(int valueA, int valueB){
        return ting::Ref<MyClass>(
                new MyClass(valueA, valueB)
            );
    }
};
}}}
Note, that constructor of the class is intentionally made private and a static New() method introduced to construct the object. This is not a mandatory technique but it is a good practice, and using this with ting::RefCounted objects is encouraged. As of current version (ting-0.4) the constructor of ting::RefCounted class is public, but it is possible that in later versions of ting it will be made protected, so it will only be possible to construct the object from within its own method, e.g. New(). Also, using this practice will help you assure that the object of your class will only be accessed through ting::Ref references, and not via traditional C pointers, whose usage with ting::RefCounted, if not forbidden, then, at least, strongly _not_ recommended.



<br>
= Referencing objects with ting::Ref =

_ting::Ref_ is a template class representing a hard reference to reference counted object (derived from ting::RefCounted). Note, that it is not allowed to create references using *new* operator (the *new* operator is private anyway).

The usage is quite simple:

{{{
//create first object
ting::Ref<MyClass> globalMC = MyClass::New(0, 1);;

{
    //create second object
    ting::Ref<MyClass> mc = MyClass::New(13, 14);

    mc->a = 15;
    int k = mc->b;

    globalMC = mc;
    //At this point, the first object will be deleted.
    //And "globalRC" reference is pointing to second object as "mc" does.
}
//At this point the "mc" reference is destroyed as it went out of scope.
//But "globalMC" still references to the second object.

glomalMC.Reset();//Reset this reference, it will no longer point to any object.
//At this point, the second object will be deleted, as the last hard reference
//to it was destroyed, or reset.
}}}



<br>
= Referencing objects with ting::WeakRef =

_ting::WeakRef_ is a template class representing a weak reference. Weak reference does not guarantee that the object is still alive. Actually, if there are several hard references to the object and there are several weak references to the same object, then, after all hard references go out of scope the object will be destroyed immediately, despite the fact that some weak references still exist.

Note, that it is not allowed to access the object through weak reference directly. In order to access the object, one needs to construct a hard reference from the weak reference and then check that the constructed hard reference is valid. If the constructed hard reference is not valid, then the object was deleted before because all hard references to it have ceased to exist.

The usage is as follows:
{{{
//create object
ting::Ref<MyClass> mc = MyClass::New(13, 14);

//create weak reference to the object
ting::WeakRef<MyClass> wmc = mc;

//access some object member using the weak reference
if(ting::Ref<MyClass> hmc = wmc){
    hmc->a = 35;
    int k = hmc->b;
    //...
}

//destroy last hard reference to the object
mc.Reset();//the object will be deleted

//try accessing some object member using the weak reference
if(ting::Ref<MyClass> hmc = wmc){
   //Will never get there as the object is destroyed and
   //weak reference in not valid anymore
}
}}}