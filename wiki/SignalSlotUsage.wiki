#summary Signal-slot callback mechanism usage

= Introduction =

*ting* offers implementation of a signal-slot callback mechanism. The implementation is based on C++ templates and C preprocessor. No additional tools or code generators needed.



<br>
= Concept =

Signal-slot is a technique of calling callback functions. The callback function may be an ordinary C-like function or function-member of some class. In latter case, it should be used in conjunction with object, for which the function-member is to be called.

The _*signal*_ is an object which holds list of callbacks it should call when needed.

The _*slot*_ is actually a callback function which is to be called.

When adding a pointer to callback function to the callbacks list of a signal it is said that one connects a signal to a slot.

When signal starts calling all the callbacks it has in its list, it is said that the signal is emitted.

Signal is emitted by someone who wants to call the callbacks. In *ting* it is done by calling the Emit() method of Signal object.

Signal may have arguments. The arguments are passed to the signal by callee as arguments to signal's Emit() method. Then, these arguments will be passed to every callback function (to every slot) in the signal's list.

Signal can only be connected to those slots whose arguments match the ones of the signal. Although, it is also possible to connect the signal to slots with shorter list of arguments, in which case the rest of the signal arguments will not be passed to the slot function when the signal is emitted.

It is possible to disconnect a signal from particular slot or from all slots it is currently connected to.

*ting* signal-slot implementation is thread-safe in the sense that it is safe to connect, disconnect and emit signals from different threads. E.g. if one thread emits the signal and the other one tries to connect it to some slot.



<br>
= Header file =
In order to use ting signal-slot, one needs to include this header file:
{{{
#include <ting/Signal.hpp>
}}}



<br>
= Signal objects =

There is a _ting::Signal0_ class which represents a signal with 0 arguments.<br>
And, there are template classes like:<br>
_ting::Signal1_<br>
_ting::Signal2_<br>
...<br>
_ting::Signal10_<br>

which represent a signals with different number of arguments (from 1 to 10).

To create a signal object with 0 arguments just do this:
{{{
ting::Signla0 mySignal;
}}}

To create a signal, for example, with 3 arguments of types {{{int}}}, {{{char}}} and {{{int*}}}, do the following:
{{{
ting::Signal3<int, char, int*> mySignalWithArgs;
}}}

The signal can then be emitted, whenever needed:
{{{
mySignal.Emit();

int intArray[2] = {13, 14};
mySignalWithArgs.Emit(10, 'f', intArray);
}}}


<br>
= Connecting signal to a simple Function slot =

It is possible to connect the signal to any function (function slot) which matches its arguments list with signal's arguments list or has shorter
arguments list than signal has but with matching argument types.

Note, it is not important which value the function returns, return values are ignored when emitting the signal.

Connecting slots without arguments:
{{{
void MyFunctionSlotWith_0_Args(){
    std::cout << "Hello World!" << std::endl;
}

mySignal.Connect(&MyFunctionSlotWith_0_Args);
mySignal.Emit();
}}}
As a result, the following will be printed:
{{{
Hello World!
}}}


Connecting slots with arguments:
{{{
void MyFunctionSlotWith_0_Args(){
    std::cout << "0 args func called" << std::endl;
}

char MyFunctionSlotWith_1_Arg(int a){
    std::cout << "1 arg func called, a = " << a << std::endl;
    return 'J';
}

void MyFunctionSlotWith_3_Args(int a, char c, int* ia){
    std::cout << "3 arg func called" << std::endl;
}

int MyOverloadedFunctionSlot(int a){
    std::cout << "1 arg overloaded func called, a = " << a << std::endl;
    return 3544;
}

bool MyOverloadedFunctionSlot(int a, char c){
    std::cout << "2 arg overloaded func called, a = " << a << std::endl;
    return false;
}

//connect slots to signal

mySignalWithArgs.Connect(&MyFunctionSlotWith_0_Args);
mySignalWithArgs.Connect(&MyFunctionSlotWith_1_Arg);
mySignalWithArgs.Connect(&MyFunctionSlotWith_3_Args);

//when connecting overloaded functions, it is necessary to indicate which one
//you are exactly connecting by using C-style cast.
mySignalWithArgs.Connect((int(*)(int)) &MyOverloadedFunctionSlot);
mySignalWithArgs.Connect((bool(*)(int, char)) &MyOverloadedFunctionSlot);

mySignalWithArgs.Emit(13, 'G', 0);//3rd argument is just a 0 pointer to int.
}}}
As a result, the following will be printed:
{{{
0 args func called
1 arg func called, a = 13
3 arg func called
1 arg overloaded func called, a = 13
2 arg overloaded func called, a = 13
}}}

Note, that the above function slots have different types of return value. This is intentionally made to demonstrate that the return value does not matter and is ignored.



<br>
= Connecting signal to a Function-member slot =
{{{
class MyClass{
    int classData;
public:
    MyClass(int data) :
            classData(data)
    {}

    void MemberSlotWith_3_Args(int a, char c, int* ia){
        std::cout << "3 arg method called, classData = " << classData << std::endl;
    }

    int OverloadedMemberSlot(int a){
        std::cout << "1 arg overloaded method called, a = " << a << std::endl;
        return 3544;
    }

    bool OverloadedMemberSlot(int a, char c){
        std::cout << "2 arg overloaded method called, a = " << a << std::endl;
        return false;
    }
};

MyClass obj(14);

mySignalWithArgs.Connect(&obj, &MyClass::MemberSlotWith_3_Args);

//when connecting overloaded methods it is necessary to
//indicate which one exactly you are connecting by using C-style cast
mySignalWithArgs.Connect(
        &obj,
        (int(MyClass::*)(int)) &MyClass::OverloadedMemberSlot
    );
mySignalWithArgs.Connect(
        &obj,
        (bool(MyClass::*)(int, char)) &MyClass::OverloadedMemberSlot
    );

mySignalWithArgs.Emit(13, 'G', 0);//3rd argument is just a 0 pointer to int.
}}}

As a result, the following will be printed:
{{{
3 arg method called, classData = 14
1 arg overloaded method called, a = 13
2 arg overloaded method called, a = 13
}}}


<br>
= Connecting signal to a Function-member slot using !ting::WeakRef =

It is possible to connect signal to function-members slot using the !_ting::WeakRef_ instead of traditional C-like pointer. It is done in a very similar way, just pass a !_ting::WeakRef_ to the object instead of traditional pointer to the object as a first argument of Connect().



<br>
= Disconnecting =

Disconnecting a signal from a particular slot is done similarly to connecting. Just use Disconnect() instead of Connect().

Note, the Disconnect() method returns bool value indicating that the slot was actually disconnected or not. If it is {{{true}}} then the slot was disconnected. If it is {{{false}}} then the slot was not disconnected, possibly, due to it was not connected before to this signal.