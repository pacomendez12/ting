#summary Signal-slot callback mechanism usage

= Introduction =

*ting* offers implementation of a signal-slot callback mechanism. The implementation is based on C++ templates and C preprocessor. No additional tools or code generators needed.



<br>
= Concept =

Signal-slot is a technique of calling callback functions. The callback function may be an ordinary C-like function or function-member of some class. In latter case, it should be used in conjunction with object, for which the function-member is to be called.

The _*signal*_ is an object which holds list of callbacks it should call when needed.

The _*slot*_ is actually a callback function which is to be called.

When adding a pointer to callback function to the callbacks list of a signal it is said that one connects a signal to a slot.

When signal starts calling all the callbacks it has in its list, it is said that the signal is emitted.

Signal is emitted by someone who wants to call the callbacks. In *ting* it is done by calling the Emit() method of Signal object.

Signal may have arguments. The arguments are passed to the signal by callee as arguments to signal's Emit() method. Then, these arguments will be passed to every callback function (to every slot) in the signal's list.

Signal can only be connected to those slots whose arguments match the ones of the signal. Although, it is also possible to connect the signal to slots with shorter list of arguments, in which case the rest of the signal arguments will not be passed to the slot function when the signal is emitted.

It is possible to disconnect a signal from particular slot or from all slots it is currently connected to.

*ting* signal-slot implementation is thread-safe in the sense that it is safe to connect, disconnect and emit signals from different threads. E.g. if one thread emits the signal and the other one tries to connect it to some slot.



<br>
= Header file =
In order to use ting signal-slot, one needs to include this header file:
{{{
#include <ting/Signal.hpp>
}}}



<br>
= Signal objects =

There is a _ting::Signal0_ class which represents a signal with 0 arguments.<br>
And, there are template classes like:<br>
_ting::Signal1_<br>
_ting::Signal2_<br>
...<br>
_ting::Signal10_<br>

which represent a signals with different number of arguments (from 1 to 10).

To create a signal object with 0 arguments just do this:
{{{
ting::Signla0 mySignal;
}}}

To create a signal, for example, with 3 arguments of types {{{int}}}, {{{char}}} and {{{int*}}}, do the following:
{{{
ting::Signal3<int, char, int*> mySignalWithArgs;
}}}

The signal can then be emitted, whenever needed:
{{{
mySignal.Emit();

int intArray[2] = {13, 14};
mySignalWithArgs.Emit(10, 'f', intArray);
}}}


<br>
= Connecting simple Function slot to a signal =

It is possible to connect the signal to any function (function slot) which matches its arguments list with signal's arguments list or has shorter
arguments list than signal has but with matching argument types.

Note, it is not important which value the function returns, return values are ignored when emitting the signal.

Connecting slots without arguments:
{{{
void MyFunctionSlotWith_0_Args(){
    std::cout << "Hello World!" << std::endl;
}

mySignal.Connect(&MyFunctionSlotWith_0_Args);
mySignal.Emit();
}}}
As a result, the following will be printed:
{{{
Hello World!
}}}


Connecting slots with arguments:
{{{
void MyFunctionSlotWith_0_Args(){
    std::cout << "0 args func called" << std::endl;
}

void MyFunctionSlotWith_1_Arg(int a){
    std::cout << "1 arg func called, a = " << a << std::endl;
}

void MyFunctionSlotWith_3_Args(int a, char c, int* ia){
    std::cout << "3 arg func called" << std::endl;
}

void MyOverloadedFunctionSlot(int a){
    std::cout << "1 arg overloaded func called, a = " << a << std::endl;
}

void MyOverloadedFunctionSlot(int a, char c){
    std::cout << "2 arg overloaded func called, a = " << a << std::endl;
}




}}}